{"version":3,"sources":["webpack://planarity_knot/./lib/color.js","webpack://planarity_knot/./lib/game.js","webpack://planarity_knot/./lib/game_view.js","webpack://planarity_knot/./lib/graph.js","webpack://planarity_knot/./lib/line.js","webpack://planarity_knot/./lib/null_object.js","webpack://planarity_knot/./lib/player.js","webpack://planarity_knot/./lib/point.js","webpack://planarity_knot/./lib/util.js","webpack://planarity_knot/webpack/bootstrap","webpack://planarity_knot/./lib/planarity_knot.js"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACNA,cAAc,mBAAO,CAAC,+BAAS;AAC/B,eAAe,mBAAO,CAAC,iCAAU;AACjC,cAAc,mBAAO,CAAC,+BAAS;AAC/B,aAAa,mBAAO,CAAC,6BAAQ;AAC7B,eAAe,mBAAO,CAAC,wCAAe;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,wEAAwE;AAC/F;;;AAGA;AACA,wCAAwC,wEAAwE;AAChH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,wEAAwE;AAC/F,yDAAyD,WAAW;AACpE,yDAAyD,kBAAkB;;AAE3E;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2EAA2E,eAAe;AAC1F;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;;AAEA;AACA;AACA,yDAAyD,kBAAkB;AAC3E;;AAEA;AACA;AACA,yDAAyD,WAAW;AACpE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;;;;;;;;;;ACvHA,aAAa,mBAAO,CAAC,6BAAQ;AAC7B,aAAa,mBAAO,CAAC,6BAAQ;;AAE7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC,OAAO;AACP;AACA;AACA,uBAAuB,UAAU;AACjC,SAAS;AACT,GAAG;AACH;;AAEA;;;;;;;;;;;AC9CA,aAAa,mBAAO,CAAC,6BAAQ;AAC7B,cAAc,mBAAO,CAAC,+BAAS;AAC/B,mBAAmB,mBAAO,CAAC,2CAAe;AAC1C,aAAa,mBAAO,CAAC,6BAAQ;;AAE7B;AACA;AACA;AACA;;AAEA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,8CAA8C;AAC/D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,8DAA8D,sBAAsB;AACpF,+DAA+D,iBAAiB;AAChF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,cAAc;AAChD,sCAAsC,cAAc;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D,oCAAoC,0BAA0B;AAC9D;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,8BAA8B,yEAAyE;AACvG,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA,8BAA8B,wBAAwB;AACtD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;;AAEA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA,8BAA8B,uBAAuB;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iEAAiE,mCAAmC;AACpG,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,+DAA+D,iBAAiB;AAChF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gEAAgE,sBAAsB;AACtF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;AChYA,aAAa,mBAAO,CAAC,6BAAQ;AAC7B,cAAc,mBAAO,CAAC,+BAAS;AAC/B,cAAc,mBAAO,CAAC,+BAAS;;;AAG/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;AC1GA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACPA;AACA;AACA;;AAEA;;;;;;;;;;;ACJA,cAAc,mBAAO,CAAC,+BAAS;AAC/B,aAAa,mBAAO,CAAC,6BAAQ;;AAE7B,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA,4BAA4B,cAAc;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;;;;;;;UCpHA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;ACtBA,aAAa,mBAAO,CAAC,6BAAQ;AAC7B,iBAAiB,mBAAO,CAAC,uCAAa;AACtC,aAAa,mBAAO,CAAC,6BAAQ;;AAE7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,CAAC","file":"bundle.js","sourcesContent":["module.exports = {\r\n\tSTATIC_POINT: \"#352CB3\",\r\n\tMOVING_POINT: \"#331385\",\r\n  BG: \"#101010\",\r\n  LINE: \"#B1E0C0\",\r\n  INTERSECTED_LINE: \"#43B768\"\r\n};\r\n","const Graph = require(\"./graph\");\r\nconst Player = require(\"./player\");\r\nconst Color = require(\"./color\");\r\nconst Util = require(\"./util\");\r\nconst graphs = require('./graphs.json');\r\nconst Game = function (opts) {\r\n  this.graph = new Graph();\r\n  this.player = new Player();\r\n  this.level = 1;\r\n  this.bindEventListeners();\r\n};\r\n\r\nGame.prototype.start = function () {\r\n  this.graph.populate({ level: this.level, renderLevelUpBtn: this.renderLevelUpBtn.bind(this) });\r\n};\r\n\r\n\r\nGame.prototype.readFromFile = function () {\r\n  this.graph.makeGraphFromJSON(graphs, { level: this.level, renderLevelUpBtn: this.renderLevelUpBtn.bind(this) })\r\n}\r\n\r\nGame.prototype.bindEventListeners = function () {\r\n  //add icon onClick event handlers\r\n  Util.onClassClick('fa-repeat', () => {\r\n    this.readFromFile();\r\n    //this.levelTwo();\r\n  });\r\n\r\n  Util.onClassClick('fa-backward', () => {\r\n    this.level = 1;\r\n    this.readFromFile();\r\n  });\r\n\r\n  Util.onClassClick('btn-level1', () => {\r\n    this.level = 1;\r\n    this.readFromFile();\r\n  })\r\n\r\n  Util.onClassClick('btn-level2', () => {\r\n    this.level = 2;\r\n    this.readFromFile();\r\n  })\r\n\r\n  Util.onClassClick('fa-question-circle-o', () => {\r\n    this.graph.pauseTimer();\r\n    Util.unhide('instructions-modal');\r\n  });\r\n\r\n  Util.onIdClick('play-btn', () => {\r\n    this.graph.startTimer();\r\n    Util.hide('instructions-modal');\r\n  });\r\n\r\n  Util.onIdClick('level-up-btn', () => {\r\n    this.levelUp();\r\n    this.graph.resetTimer();\r\n    this.graph.startTimer();\r\n    Util.hide('level-up-btn');\r\n  });\r\n};\r\n\r\nGame.prototype.resetLevel = function () {\r\n  this.graph.pauseTimer();\r\n  this.graph.resetTimer();\r\n  this.graph.restoreStartingGraph();\r\n  this.graph.startTimer();\r\n};\r\n\r\nGame.prototype.startNewGame = function () {\r\n  this.graph.pauseTimer();\r\n  this.graph.resetTimer();\r\n\r\n  this.player = new Player();\r\n  this.level = 1;\r\n  this.graph.populate({ level: this.level, renderLevelUpBtn: this.renderLevelUpBtn.bind(this) });\r\n  document.getElementById(\"level\").innerHTML = `Level: ${this.level}`;\r\n  document.getElementById(\"score\").innerHTML = `Score: ${this.player.score}`;\r\n\r\n  this.redrawGameView();\r\n\r\n  this.graph.startTimer();\r\n};\r\n\r\nGame.prototype.receiveRedrawGameView = function (opts) {\r\n  this.redrawGameView = opts.redrawGameView;\r\n};\r\n\r\nGame.prototype.renderLevelUpBtn = function () {\r\n  this.graph.pauseTimer();\r\n  document.getElementById('level-up-btn').innerHTML = `Continue to level ${this.level + 1} <i class=\"fa fa-hand-o-right\" aria-hidden=\"true\"></i></i>`;\r\n  Util.unhide('level-up-btn');\r\n};\r\n\r\nGame.prototype.levelUp = function () {\r\n  this.updateScore();\r\n  this.graph.resetTimer();\r\n  this.updateLevel();\r\n  this.graph.populate({ level: this.level });\r\n};\r\n\r\nGame.prototype.updateScore = function () {\r\n  this.player.score += this.graph.currentMoveCount * this.graph.elapsedTime;\r\n  document.getElementById(\"score\").innerHTML = `Score: ${this.player.score}`;\r\n};\r\n\r\nGame.prototype.updateLevel = function () {\r\n  this.level += 1;\r\n  document.getElementById(\"level\").innerHTML = `Level: ${this.level}`;\r\n};\r\n\r\nGame.prototype.draw = function (ctx) {\r\n  ctx.clearRect(0, 0, Util.DIM_X, Util.DIM_Y);\r\n  ctx.fillStyle = Color.BG;\r\n  ctx.fillRect(0, 0, Util.DIM_X, Util.DIM_Y);\r\n\r\n  this.graph.draw(ctx);\r\n};\r\n\r\n\r\nmodule.exports = Game;\r\n","const Game = require(\"./game\");\r\nconst Util = require(\"./util\");\r\n\r\nconst GameView = function (game, ctx) {\r\n  this.ctx = ctx;\r\n  this.game = game;\r\n  this.game.draw(ctx);\r\n  this.bindEventHandlers();\r\n};\r\n\r\nGameView.prototype.bindEventHandlers = function () {\r\n  this.game.receiveRedrawGameView({\r\n    redrawGameView: this.redrawGameView.bind(this)\r\n  });\r\n\r\n  this.game.graph.receiveRedrawGameView({\r\n    redrawGameView: this.redrawGameView.bind(this)\r\n  });\r\n\r\n  this.displayCaptionsOnHover([\r\n    'fa-repeat',\r\n    'fa-backward',\r\n    'fa-question-circle-o',\r\n    'fa-github',\r\n    'fa-linkedin'\r\n  ]);\r\n};\r\n\r\nGameView.prototype.redrawGameView = function (e) {\r\n  Util.hide('level-up-btn');\r\n  this.game.draw(this.ctx);\r\n};\r\n\r\nGameView.prototype.displayCaptionsOnHover = function (iconClasses) {\r\n  iconClasses.forEach(iconClass => {\r\n    document.getElementsByClassName(iconClass)[0].addEventListener(\r\n      'mouseover', () => {\r\n        Util.unhide(`${iconClass}-caption`);\r\n      });\r\n      document.getElementsByClassName(iconClass)[0].addEventListener(\r\n        'mouseout', () => {\r\n          Util.hide(`${iconClass}-caption`);\r\n        });\r\n  });\r\n};\r\n\r\nmodule.exports = GameView;\r\n","const Line = require(\"./line\");\r\nconst Point = require(\"./point\");\r\nconst NullObject = require(\"./null_object\");\r\nconst Util = require(\"./util\");\r\n\r\nconst Graph = function () {\r\n  this.clearGraph();\r\n  this.bindEventListeners();\r\n};\r\n\r\nGraph.prototype.populate = function (opts = {}) {\r\n  console.log('mouseup');\r\n  this.renderLevelUpBtn = opts.renderLevelUpBtn ? opts.renderLevelUpBtn : this.renderLevelUpBtn;\r\n  this.level = opts.level;\r\n  this.setLinesAndPoints(opts);\r\n  if (this.intersectionCount < 1) {\r\n    this.populate(opts);\r\n  } else {\r\n    this.redrawGameView();\r\n  }\r\n  this.pauseTimer();\r\n  this.resetTimer();\r\n};\r\n\r\nGraph.prototype.receiveRedrawGameView = function (opts) {\r\n  this.redrawGameView = opts.redrawGameView;\r\n};\r\n\r\nGraph.prototype.setLinesAndPoints = function (opts) {\r\n  let level = opts.level;\r\n  let premadePoints = opts.initialPoints;\r\n  let premadePointPositions = opts.initialPointPositions;\r\n\r\n  let isRestoringLevel = Boolean(premadePoints && premadePointPositions);\r\n  let numPoints = level;\r\n  let numConnectingLines = Math.floor(level / 2);\r\n\r\n  if (level < 2) {\r\n    numPoints += 4;\r\n  } else if (level < 3) {\r\n    numPoints += 4;\r\n    numConnectingLines = 1;\r\n  } else if (level < 6) {\r\n    numPoints += 3;\r\n    numConnectingLines = 2;\r\n  } else if (level < 8) {\r\n    numPoints += 2;\r\n    numConnectingLines = 3;\r\n  } else if (level < 10) {\r\n    numPoints += 1;\r\n    numConnectingLines = 4;\r\n  } else if (level > 14) {\r\n    numPoints -= Math.floor(level / 4);\r\n    if (level > 16) numConnectingLines = 7;\r\n  }\r\n\r\n  this.clearGraph();\r\n\r\n  if (isRestoringLevel) {\r\n    this.points = Point.deepDup(premadePoints);\r\n    this.pointPositions = Util.clonePositions(premadePointPositions);\r\n  } else {\r\n    this.clearInitialPoints();\r\n    this.makePoints(numPoints);\r\n  }\r\n\r\n  this.makeBaseLines(numPoints);\r\n  this.makeConnectingLines(numConnectingLines);\r\n  this.setIntersectionData(this.lines);\r\n};\r\n\r\nGraph.prototype.setIntersectionData = function (lines) {\r\n  Line.setIntersectionPositions(lines);\r\n  this.countIntersections();\r\n};\r\n\r\nGraph.prototype.restoreStartingGraph = function () {\r\n  let level = this.level;\r\n  let initialPoints = this.initialPoints;\r\n  let initialPointPositions = this.initialPointPositions;\r\n\r\n  this.populate({ level, initialPoints, initialPointPositions });\r\n};\r\n\r\nGraph.prototype.countIntersections = function () {\r\n  let allLines = this.movingLines.length > 1 ? [].concat(this.lines, this.movingLines) : this.lines;\r\n  this.intersectionCount = Line.intersectionCount(allLines);\r\n};\r\n\r\nGraph.prototype.clearGraph = function () {\r\n  this.lines = [];\r\n  this.points = [];\r\n  this.pointPositions = [];\r\n  this.intersectionCount = 0;\r\n\r\n  this.currentMoveCount = 0;\r\n  this.timer = null;\r\n  this.elapsedTime = 0;\r\n\r\n  this.movingPoint = new NullObject();\r\n  this.movingLines = [new NullObject()];\r\n\r\n  document.getElementById('move-count').innerHTML = `Moves: ${this.currentMoveCount}`;\r\n  document.getElementById('elapsed-time').innerHTML = `Time: ${this.elapsedTime}`;\r\n};\r\n\r\nGraph.prototype.clearInitialPoints = function () {\r\n  this.initialPoints = [];\r\n  this.initialPointPositions = [];\r\n  this.initialLines = [];\r\n};\r\n\r\nGraph.prototype.makePoints = function (n) {\r\n  this.points = [];\r\n  this.pointPositions = [];\r\n  this.initialPoints = [];\r\n  this.initialPointPositions = [];\r\n\r\n  while (this.points.length < n) {\r\n    const x = Math.floor(Math.random() * (Util.DIM_X - 260) + 130);\r\n    const y = Math.floor(Math.random() * (Util.DIM_Y - 260) + 130)\r\n\r\n    if (Point.hasEnoughSpace([x, y], this.pointPositions)) {\r\n      this.pointPositions.push([x, y]);\r\n      this.initialPointPositions.push([x, y]);\r\n      const newPoint = new Point({ pos: [x, y] });\r\n      const newInitPoint = new Point({ pos: [x, y] });\r\n      this.points.push(newPoint);\r\n      this.initialPoints.push(newInitPoint);\r\n    }\r\n  }\r\n};\r\n\r\nGraph.prototype.makeGraphFromJSON = function (file, opts) {\r\n  this.points = []\r\n  this.pointPositions = []\r\n  this.initialPoints = [];\r\n  this.initialPointPositions = [];\r\n\r\n  this.renderLevelUpBtn = opts.renderLevelUpBtn ? opts.renderLevelUpBtn : this.renderLevelUpBtn;\r\n  this.level = opts.level;\r\n\r\n  this.clearGraph();\r\n\r\n  //create vertices\r\n  file[opts.level - 1].Points.forEach(point => {\r\n    this.pointPositions.push([point.x, point.y]);\r\n    this.initialPointPositions.push([point.x, point.y]);\r\n    const newPoint = new Point({ pos: [point.x, point.y] });\r\n    const newInitPoint = new Point({ pos: [point.x, point.y] });\r\n    this.points.push(newPoint);\r\n    this.initialPoints.push(newInitPoint);\r\n  });\r\n\r\n  //create Edges\r\n  this.lines = [];\r\n  file[opts.level - 1].Edges.forEach(edge => {\r\n    this.lines.push(new Line({ startPoint: this.points[edge.V_FROM], endPoint: this.points[edge.V_TO] }));\r\n  });\r\n\r\n  this.setIntersectionData(this.lines);\r\n  this.redrawGameView();\r\n  this.pauseTimer();\r\n  this.resetTimer();\r\n}\r\n\r\nGraph.prototype.makeBaseLines = function (n) {\r\n  this.lines = [];\r\n  for (var i = 0; i < n; i++) {\r\n    const startPoint = this.points[i];\r\n    const endPoint = this.points[i + 1] ? this.points[i + 1] : this.points[0];\r\n    const newLine = new Line({ startPoint, endPoint, });\r\n    this.lines.push(newLine);\r\n  }\r\n};\r\n\r\nGraph.prototype.makeConnectingLines = function (n) {\r\n  let startPoint;\r\n  let endPoint;\r\n\r\n  let createFirstConnectingLine = () => {\r\n    startPoint = this.points[0];\r\n    endPoint = this.points[3];\r\n    let newLine = new Line({ startPoint, endPoint });\r\n    this.lines.push(newLine);\r\n  };\r\n\r\n  let createSecondConnectingLine = () => {\r\n    startPoint = this.points[0];\r\n    endPoint = this.points[4];\r\n    let newLine = new Line({ startPoint, endPoint });\r\n    this.lines.push(newLine);\r\n  };\r\n\r\n  let createThirdConnectingLine = () => {\r\n    startPoint = this.points[this.points.length - 1];\r\n    endPoint = this.points[5];\r\n    let newLine = new Line({ startPoint, endPoint });\r\n    this.lines.push(newLine);\r\n  };\r\n\r\n  let createNMoreConnectingLines = (nMore) => {\r\n    for (var i = 0; i < nMore; i++) {\r\n      startPoint = this.points[this.points.length - 1];\r\n      endPoint = this.points[this.points.length - (i + 5)];\r\n      let newLine = new Line({ startPoint, endPoint });\r\n      this.lines.push(newLine);\r\n      nMore -= 1;\r\n    }\r\n  };\r\n\r\n  if (n > 0) createFirstConnectingLine();\r\n  if (n > 1) createSecondConnectingLine();\r\n  if (n > 2) createThirdConnectingLine();\r\n  if (n > 3) createNMoreConnectingLines(n - 3);\r\n\r\n};\r\n\r\nGraph.prototype.draw = function (ctx) {\r\n  this.allObjects().forEach((object) => {\r\n    object.draw(ctx);\r\n  });\r\n};\r\n\r\nGraph.prototype.allObjects = function () {\r\n  return [].concat(this.lines, this.points, this.movingLines, this.movingPoint);\r\n};\r\n\r\nGraph.prototype.startTimer = function (opts) {\r\n  this.timer = setInterval(() => {\r\n    this.elapsedTime += 1;\r\n\r\n    document.getElementById('elapsed-time').innerHTML = `Time: ${(this.elapsedTime / 10).toFixed(1)}`;\r\n  }, 100);\r\n};\r\n\r\nGraph.prototype.pauseTimer = function () {\r\n  if (this.timer) clearInterval(this.timer);\r\n  this.timer = null;\r\n};\r\n\r\nGraph.prototype.resetTimer = function (opts) {\r\n  this.elapsedTime = 0;\r\n  document.getElementById('elapsed-time').innerHTML = `Time: ${this.elapsedTime}`;\r\n};\r\n\r\nGraph.prototype.bindEventListeners = function () {\r\n  document.onmousedown = this.onMouseDown.bind(this);\r\n  document.onmousemove = this.listenForHoveringOverPoint.bind(this);\r\n};\r\n\r\nGraph.prototype.onMouseDown = function (e) {\r\n  let mousePos = [e.offsetX, e.offsetY];\r\n  if (this.isMouseOnPoint(mousePos)) {\r\n    document.getElementById('canvas').style.cursor = '-webkit-grab';\r\n    this.currentMoveCount += 1;\r\n    document.getElementById('move-count').innerHTML = `Moves: ${this.currentMoveCount}`;\r\n    this.isolateMovingObjects(mousePos);\r\n    document.onmousemove = this.onMouseMoveWhileMouseDown.bind(this);\r\n    document.onmouseup = this.onMouseUp.bind(this);\r\n  }\r\n};\r\n\r\nGraph.prototype.listenForHoveringOverPoint = function (e) {\r\n  let mousePos = [e.offsetX, e.offsetY];\r\n  if (this.isMouseOnPoint(mousePos)) {\r\n    document.getElementById('canvas').style.cursor = '-webkit-grab';\r\n  } else {\r\n    document.getElementById('canvas').style.cursor = 'inherit';\r\n  }\r\n};\r\n\r\nGraph.prototype.isMouseInRange = function (mousePos) {\r\n  console.log(mousePos);\r\n  return true;\r\n};\r\n\r\nGraph.prototype.onMouseMoveWhileMouseDown = function (e) {\r\n  let mouseX = e.offsetX;\r\n  let mouseY = e.offsetY;\r\n  let mousePos = [mouseX, mouseY];\r\n  console.log(mousePos);\r\n  if (this.isMouseInRange(mousePos)) {\r\n    this.updateMovingObjects(mousePos);\r\n    this.redrawGameView();\r\n  }\r\n};\r\n\r\nGraph.prototype.onMouseUp = function (e) {\r\n  let mouseX = e.offsetX;\r\n  let mouseY = e.offsetY;\r\n  let mousePos = [mouseX, mouseY];\r\n  this.settlizeMovingObjects(mousePos);\r\n  this.redrawGameView();\r\n  if (this.isPlanar()) {\r\n    this.pauseTimer();\r\n    this.renderLevelUpBtn();\r\n  }\r\n  document.onmousemove = this.listenForHoveringOverPoint.bind(this);\r\n  document.onmouseup = null;\r\n};\r\n\r\nGraph.prototype.setMovingPoint = function (mousePos) {\r\n  this.movingPoint = this.points.filter(point => point.isMouseOnMe(mousePos))[0];\r\n};\r\n\r\nGraph.prototype.setMovingLines = function () {\r\n  this.movingLines = this.lines.filter(line => {\r\n    let isStartPointMoving = Util.samePos(line.startPoint.pos, this.movingPoint.pos);\r\n    let isEndPointMoving = Util.samePos(line.endPoint.pos, this.movingPoint.pos);\r\n    if (isStartPointMoving) {\r\n      line.startPoint.isMoving = true;\r\n    } else if (isStartPointMoving) {\r\n      line.endPoint.isMoving = true;\r\n    }\r\n    return (isStartPointMoving || isEndPointMoving);\r\n  });\r\n};\r\n\r\nGraph.prototype.removeMovingLinesfromLinesArr = function () {\r\n  this.lines = this.lines.filter(line => {\r\n    return !(line.startPoint.isMoving || line.endPoint.isMoving);\r\n  });\r\n};\r\n\r\nGraph.prototype.removeMovingPointfromPointsArr = function (mousePos) {\r\n  this.points = this.points.filter(point => !point.isMouseOnMe(mousePos));\r\n};\r\n\r\nGraph.prototype.isolateMovingObjects = function (mousePos) {\r\n  this.setMovingPoint(mousePos);\r\n  this.setMovingLines();\r\n  this.removeMovingPointfromPointsArr(mousePos);\r\n  this.removeMovingLinesfromLinesArr();\r\n  this.movingPoint.isMoving = true;\r\n};\r\n\r\nGraph.prototype.settlizeMovingObjects = function (mousePos) {\r\n  this.updateMovingObjects(mousePos);\r\n  this.movingPoint.isMoving = false;\r\n  this.movingLines.forEach(line => {\r\n    if (line.startPoint.isMoving) {\r\n      line.startPoint.isMoving = false;\r\n    } else if (line.endPoint.isMoving) {\r\n      line.endPoint.isMoving = false;\r\n    }\r\n  });\r\n  this.points = this.points.concat(this.movingPoint);\r\n  this.lines = this.lines.concat(this.movingLines);\r\n  this.movingPoint = new NullObject();\r\n  this.movingLines = [new NullObject()];\r\n};\r\n\r\nGraph.prototype.updateMovingObjects = function (mousePos) {\r\n  this.moveMovingObjects(mousePos);\r\n  Line.setIntersectionPositions([].concat(this.lines, this.movingLines));\r\n};\r\n\r\nGraph.prototype.isPlanar = function () {\r\n  this.countIntersections();\r\n  return Boolean(this.intersectionCount < 1);\r\n};\r\n\r\nGraph.prototype.moveMovingObjects = function (mousePos) {\r\n  mousePos = [\r\n    mousePos[0] - Util.POINT_RADIUS,\r\n    mousePos[1] - Util.POINT_RADIUS\r\n  ];\r\n\r\n  this.movingPoint.pos = mousePos;\r\n  this.movingLines.forEach(line => {\r\n    if (line.startPoint.isMoving) {\r\n      line.startPoint.pos = mousePos;\r\n    } else if (line.endPoint.isMoving) {\r\n      line.endPoint.pos = mousePos;\r\n    }\r\n    line.setSlopeAndYIntercept();\r\n  });\r\n};\r\n\r\nGraph.prototype.isMouseOnPoint = function (mousePos) {\r\n  return Boolean(this.points.filter(point => point.isMouseOnMe(mousePos))[0]);\r\n};\r\n\r\nmodule.exports = Graph;\r\n","const Util = require(\"./util\");\r\nconst Color = require(\"./color\");\r\nconst Point = require(\"./point\");\r\n\r\n\r\nconst Line = function (options) {\r\n  this.startPoint = options.startPoint;\r\n  this.endPoint = options.endPoint;\r\n  this.setSlopeAndYIntercept();\r\n\r\n  this.intersectionPositions = [];\r\n};\r\n\r\nLine.prototype.setSlopeAndYIntercept = function () {\r\n  this.slope = (this.startPoint.pos[1] - this.endPoint.pos[1]) / (this.startPoint.pos[0] - this.endPoint.pos[0]);\r\n  this.yIntercept = this.startPoint.pos[1] - (this.slope * this.startPoint.pos[0]);\r\n};\r\n\r\nLine.prototype.draw = function (ctx) {\r\n  ctx.strokeStyle = (this.intersectionPositions.length > 0) ? Color.INTERSECTED_LINE : Color.LINE;\r\n  ctx.lineWidth = Util.LINE_WIDTH;\r\n  ctx.beginPath();\r\n  ctx.moveTo(this.startPoint.pos[0], this.startPoint.pos[1]);\r\n  ctx.lineTo(this.endPoint.pos[0], this.endPoint.pos[1]);\r\n  ctx.stroke();\r\n};\r\n\r\nLine.prototype.equals = function(otherLine) {\r\n  return Boolean((this.startPoint.pos[0] === otherLine.startX) &&\r\n    (this.startPoint.pos[1] === otherLine.startY) &&\r\n    (this.endPoint.pos[0] === otherLine.endX) &&\r\n    (this.endPoint.pos[1] === otherLine.endY));\r\n};\r\n\r\nLine.prototype.intersectionPos = function (otherLine) {\r\n  //return null if lines are parallel\r\n  if (this.equals(otherLine)) return null;\r\n  if (this.isAdjacentTo(otherLine)) return null;\r\n\r\n  let commonX = ((otherLine.yIntercept - this.yIntercept) / (this.slope - otherLine.slope));\r\n  let commonY = (this.slope * commonX) + this.yIntercept;\r\n  let isValidIntersection = Boolean(\r\n    this.posInRange([commonX, commonY])\r\n    && otherLine.posInRange([commonX, commonY])\r\n  );\r\n\r\n  if (isValidIntersection) {\r\n    return [commonX, commonY];\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\nLine.prototype.intersectsWith = function (otherLine) {\r\n  return Boolean(this.intersectionPos(otherLine));\r\n};\r\n\r\nLine.prototype.isAdjacentTo = function (otherLine) {\r\n  return Boolean(\r\n    Util.samePos(this.startPoint.pos, otherLine.startPoint.pos) ||\r\n    Util.samePos(this.startPoint.pos, otherLine.endPoint.pos) ||\r\n    Util.samePos(this.endPoint.pos, otherLine.endPoint.pos) ||\r\n    Util.samePos(this.endPoint.pos, otherLine.startPoint.pos)\r\n  );\r\n};\r\n\r\nLine.setIntersectionPositions = function(allLines) {\r\n  allLines.forEach(line => {\r\n    line.setIntersectionPositions(allLines);\r\n    // console.log(line.intersectionPositions);\r\n  });\r\n};\r\n\r\nLine.intersectionCount = function(allLines) {\r\n  let allPos = [];\r\n  allLines.forEach(line => {\r\n    line.setIntersectionPositions(allLines);\r\n    allPos = allPos.concat(line.intersectionPositions);\r\n  });\r\n  return Util.uniqPositions(allPos).length;\r\n};\r\n\r\nLine.prototype.setIntersectionPositions = function(allLines) {\r\n  let intersectionPositions = [];\r\n\r\n  allLines.forEach((line, i) => {\r\n    if (this.intersectsWith(line)) {\r\n      intersectionPositions.push(this.intersectionPos(line));\r\n    }\r\n  });\r\n\r\n  this.intersectionPositions = Util.uniqPositions(intersectionPositions);\r\n};\r\n\r\nLine.prototype.posInRange = function (pos) {\r\n  const x = pos[0];\r\n  const y = pos[1];\r\n\r\n  const isXInRange = Util.inRange(this.startPoint.pos[0], this.endPoint.pos[0], x) &&\r\n    Util.inRange(0, Util.DIM_X, x);\r\n  const isYInRange = Util.inRange(this.startPoint.pos[1], this.endPoint.pos[1], y) &&\r\n    Util.inRange(0, Util.DIM_Y, y);\r\n\r\n  return Boolean(isXInRange && isYInRange);\r\n};\r\n\r\nmodule.exports = Line;\r\n","const NullObject = function () {\r\n  this.intersectionPositions = [];\r\n};\r\n\r\nNullObject.prototype.draw = function (ctx) {\r\n};\r\n\r\nmodule.exports = NullObject;\r\n","const Player = function(opts) {\r\n  this.score = 0;\r\n};\r\n\r\nmodule.exports = Player;\r\n","const Color = require(\"./color\");\r\nconst Util = require(\"./util\");\r\n\r\nconst Point = function (opts = {}) {\r\n  this.pos = opts.pos;\r\n  this.isMoving = false;\r\n};\r\n\r\nPoint.prototype.dup = function() {\r\n  let newPoint = new Point({pos: this.pos});\r\n  return newPoint;\r\n};\r\n\r\nPoint.deepDup = function(pointsArr) {\r\n  let pointClones = [];\r\n  pointsArr.forEach(point => {\r\n    let pointClone = point.dup();\r\n    pointClones.push(pointClone);\r\n  });\r\n  return pointClones;\r\n};\r\n\r\nPoint.prototype.isMouseOnMe = function(mousePos) {\r\n  return Boolean(Util.POINT_RADIUS >= Util.distance(this.pos, mousePos));\r\n};\r\n\r\nPoint.prototype.draw = function (ctx) {\r\n  ctx.fillStyle = this.isMoving ? Color.MOVING_POINT : Color.STATIC_POINT;\r\n\r\n  ctx.beginPath();\r\n  ctx.arc(\r\n    this.pos[0], this.pos[1], Util.POINT_RADIUS, 0, 2 * Math.PI, true\r\n  );\r\n  ctx.fill();\r\n};\r\n\r\nPoint.hasEnoughSpace = function(newPos, takenPositions) {\r\n  let hasEnoughSpace = true;\r\n  takenPositions.forEach(function(pos) {\r\n    let xTooClose = Boolean(Math.abs(newPos[0] - pos[0]) < 50);\r\n    let yTooClose = Boolean(Math.abs(newPos[1] - pos[1]) < 50);\r\n    if (xTooClose && yTooClose) {\r\n      hasEnoughSpace = false;\r\n    }\r\n  });\r\n\r\n  return hasEnoughSpace;\r\n};\r\n\r\nmodule.exports = Point;\r\n","const Util = {\r\n  inherits(ChildClass, ParentClass) {\r\n    ChildClass.prototype = Object.create(ParentClass.prototype);\r\n    ChildClass.prototype.constructor = ChildClass;\r\n  },\r\n\r\n  samePos(pos1, pos2){\r\n    const x1 = pos1[0];\r\n    const y1 = pos1[1];\r\n\r\n    const x2 = pos2[0];\r\n    const y2 = pos2[1];\r\n\r\n    return Boolean(x1 === x2 && y1 === y2);\r\n  },\r\n\r\n  distance(pos1, pos2) {\r\n    const x1 = pos1[0];\r\n    const y1 = pos1[1];\r\n\r\n    const x2 = pos2[0];\r\n    const y2 = pos2[1];\r\n\r\n    return Math.sqrt(\r\n      Math.pow((x2 - x1), 2) + Math.pow((y2 - y1), 2)\r\n    );\r\n  },\r\n\r\n  inRange(num1, num2, numTest){\r\n\r\n    let min = (num1 <= num2) ? num1 : num2;\r\n    let max = (num1 <= num2) ? num2 : num1;\r\n\r\n    return Boolean(numTest > min && numTest < max);\r\n  },\r\n\r\n  posInRange(startPos, endPos, testPos){\r\n    const testX = testPos[0];\r\n    const testY = testPos[1];\r\n\r\n    const startX = startPos[0];\r\n    const startY = startPos[1];\r\n\r\n    const endX = endPos[0];\r\n    const endY = endPos[1];\r\n\r\n    const isXInRange = Util.inRange(startX, endX, testX);\r\n    const isYInRange = Util.inRange(startY, endY, testY);\r\n\r\n    return Boolean(isXInRange && isYInRange);\r\n  },\r\n\r\n  uniqPositions(posArray){\r\n    let uniqPositions = [];\r\n    posArray.forEach((pos1) => {\r\n      let isUniq = true;\r\n      uniqPositions.forEach((pos2) => {\r\n        let x1 = Math.floor(pos1[0]);\r\n        let y1 = Math.floor(pos1[1]);\r\n        let x2 = Math.floor(pos2[0]);\r\n        let y2 = Math.floor(pos2[1]);\r\n\r\n        if (x1 === x2 && y1 === y2) isUniq = false;\r\n      });\r\n\r\n      if(isUniq) uniqPositions.push(pos1);\r\n    });\r\n    return uniqPositions;\r\n  },\r\n\r\n  onClassClick(className, fxn){\r\n    document.getElementsByClassName(className)[0].addEventListener(\r\n      'click', fxn);\r\n  },\r\n\r\n  onIdClick(elementId, fxn){\r\n    document.getElementById(elementId).addEventListener(\r\n      'click', fxn);\r\n  },\r\n\r\n  unhide(tagName){\r\n    let isTagClass = document.getElementsByClassName(tagName)[0];\r\n    let isTagId = document.getElementById(tagName);\r\n\r\n    if (isTagClass) {\r\n      document.getElementsByClassName(tagName)[0].classList.remove('hidden');\r\n    } else if (isTagId) {\r\n      document.getElementById(tagName).classList.remove('hidden');\r\n    }\r\n  },\r\n\r\n  hide(tagName){\r\n    let isTagClass = document.getElementsByClassName(tagName)[0];\r\n    let isTagId = document.getElementById(tagName);\r\n\r\n    if (isTagClass) {\r\n      document.getElementsByClassName(tagName)[0].classList.add('hidden');\r\n    } else if (isTagId) {\r\n      document.getElementById(tagName).classList.add('hidden');\r\n    }\r\n  },\r\n\r\n  clonePositions(posArray){\r\n    let clones = [];\r\n    posArray.forEach(pos => {\r\n      clones.push([pos[0], pos[1]]);\r\n    });\r\n    return clones;\r\n  },\r\n\r\n  DIM_X: window.innerWidth - 300,\r\n  DIM_Y: window.innerHeight - 100,\r\n  POINT_RADIUS: 10,\r\n  LINE_WIDTH: 4\r\n};\r\n\r\nmodule.exports = Util;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","const Game = require(\"./game\");\r\nconst GameView = require(\"./game_view\");\r\nconst Util = require(\"./util\");\r\n\r\ndocument.addEventListener(\"DOMContentLoaded\", function () {\r\n  //set canvas size\r\n  const canvasEl = document.getElementById(\"canvas\");\r\n  canvasEl.width = Util.DIM_X;\r\n  canvasEl.height = Util.DIM_Y;\r\n\r\n  const game = new Game();\r\n  const ctx = canvasEl.getContext(\"2d\");\r\n  new GameView(game, ctx); //.start();\r\n  //game.start();\r\n  game.readFromFile();\r\n});\r\n"],"sourceRoot":""}