{"version":3,"sources":["webpack:///webpack/bootstrap a824bf6c2b241dec4e9e","webpack:///./lib/util.js","webpack:///./lib/color.js","webpack:///./lib/game.js","webpack:///./lib/point.js","webpack:///./lib/game_view.js","webpack:///./lib/graph.js","webpack:///./lib/line.js","webpack:///./lib/null_object.js","webpack:///./lib/planarity_knot.js","webpack:///./lib/player.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AChEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACNA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,sEAAsE;AAC7F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,2EAA2E,eAAe;AAC1F;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;;AAEA;AACA;AACA,yDAAyD,kBAAkB;AAC3E;;AAEA;AACA;AACA,yDAAyD,WAAW;AACpE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;;;;;;AClEA;AACA;;AAEA,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;;;;;;ACnCA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;;;;;;ACnBA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6CAA6C;AAC7C;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,gEAAgE,sBAAsB;AACtF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,YAAY;AAC9C;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;;AAEA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA,8BAA8B,qBAAqB;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iEAAiE,iBAAiB;AAClF,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+DAA+D,iBAAiB;AAChF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gEAAgE,sBAAsB;AACtF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;;;;;;ACzRA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;AC1GA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;ACPA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B,CAAC;;;;;;;ACbD;AACA;AACA;;AAEA","file":"./lib/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a824bf6c2b241dec4e9e","const Util = {\n  inherits(ChildClass, ParentClass) {\n    ChildClass.prototype = Object.create(ParentClass.prototype);\n    ChildClass.prototype.constructor = ChildClass;\n  },\n\n  samePos(pos1, pos2){\n    const x1 = pos1[0];\n    const y1 = pos1[1];\n\n    const x2 = pos2[0];\n    const y2 = pos2[1];\n\n    return Boolean(x1 === x2 && y1 === y2);\n  },\n\n  distance(pos1, pos2) {\n    const x1 = pos1[0];\n    const y1 = pos1[1];\n\n    const x2 = pos2[0];\n    const y2 = pos2[1];\n\n    return Math.sqrt(\n      Math.pow((x2 - x1), 2) + Math.pow((y2 - y1), 2)\n    );\n  },\n\n  inRange(num1, num2, numTest){\n\n    let min = (num1 <= num2) ? num1 : num2;\n    let max = (num1 <= num2) ? num2 : num1;\n\n    return Boolean(numTest > min && numTest < max);\n  },\n\n  posInRange(startPos, endPos, testPos){\n    const testX = testPos[0];\n    const testY = testPos[1];\n\n    const startX = startPos[0];\n    const startY = startPos[1];\n\n    const endX = endPos[0];\n    const endY = endPos[1];\n\n    const isXInRange = Util.inRange(startX, endX, testX);\n    const isYInRange = Util.inRange(startY, endY, testY);\n\n    return Boolean(isXInRange && isYInRange);\n  },\n\n  uniqPositions(posArray){\n    let uniqPositions = [];\n    posArray.forEach((pos1) => {\n      let isUniq = true;\n      uniqPositions.forEach((pos2) => {\n        let x1 = Math.floor(pos1[0]);\n        let y1 = Math.floor(pos1[1]);\n        let x2 = Math.floor(pos2[0]);\n        let y2 = Math.floor(pos2[1]);\n\n        if (x1 === x2 && y1 === y2) isUniq = false;\n      });\n\n      if(isUniq) uniqPositions.push(pos1);\n    });\n    return uniqPositions;\n  },\n\n  DIM_X: window.innerWidth - 300,\n  DIM_Y: window.innerHeight - 100,\n  POINT_RADIUS: 10,\n  LINE_WIDTH: 5\n};\n\nmodule.exports = Util;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/util.js\n// module id = 0\n// module chunks = 0","module.exports = {\n\tSTATIC_POINT: \"#352CB3\",\n\tMOVING_POINT: \"#331385\",\n  BG: \"#101010\",\n  LINE: \"#B1E0C0\",\n  INTERSECTED_LINE: \"#43B768\"\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/color.js\n// module id = 1\n// module chunks = 0","const Graph = require(\"./graph\");\nconst Player = require(\"./player\");\nconst Color = require(\"./color\");\nconst Util = require(\"./util\");\n\nconst Game = function(opts) {\n  this.graph = new Graph();\n  this.player = new Player();\n  this.level = 1;\n  this.graph.populate({level: this.level, renderLevelUpBtn: this.renderLevelUpBtn.bind(this)});\n  this.bindEventListeners();\n};\n\nGame.prototype.bindEventListeners = function () {\n  document.getElementsByClassName('fa-question-circle-o')[0].addEventListener(\n    'click', () => {\n      this.graph.pauseTimer();\n      document.getElementsByClassName('instructions-modal')[0].classList.remove('hidden');\n    });\n\n  document.getElementById('play-btn').addEventListener(\n    'click', () => {\n      this.graph.startTimer();\n      document.getElementsByClassName('instructions-modal')[0].classList.add('hidden');\n    });\n\n  document.getElementById('level-up-btn').addEventListener(\n    'click', () => {\n      this.levelUp();\n      this.graph.resetTimer();\n      this.graph.startTimer();\n      document.getElementById('level-up-btn').classList.add('hidden');\n    });\n};\n\nGame.prototype.renderLevelUpBtn = function () {\n  this.graph.pauseTimer();\n  document.getElementById('level-up-btn').innerHTML = `Continue to level ${this.level + 1} <i class=\"fa fa-hand-o-right\" aria-hidden=\"true\"></i></i>`;\n  document.getElementById('level-up-btn').classList.remove('hidden');\n};\n\nGame.prototype.levelUp = function () {\n  this.updateScore();\n  this.updateLevel();\n  this.graph.populate({level: this.level});\n};\n\nGame.prototype.updateScore = function () {\n  this.player.score += this.graph.currentMoveCount * this.graph.elapsedTime;\n  document.getElementById(\"score\").innerHTML = `Score: ${this.player.score}`;\n};\n\nGame.prototype.updateLevel = function () {\n  this.level += 1;\n  document.getElementById(\"level\").innerHTML = `Level: ${this.level}`;\n};\n\nGame.prototype.draw = function (ctx) {\n  ctx.clearRect(0, 0, Util.DIM_X, Util.DIM_Y);\n  ctx.fillStyle = Color.BG;\n  ctx.fillRect(0, 0, Util.DIM_X, Util.DIM_Y);\n\n  this.graph.draw(ctx);\n};\n\n\nmodule.exports = Game;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/game.js\n// module id = 2\n// module chunks = 0","const Color = require(\"./color\");\nconst Util = require(\"./util\");\n\nconst Point = function (opts = {}) {\n  this.pos = opts.pos;\n  this.isMoving = false;\n};\n\nPoint.prototype.isMouseOnMe = function(mousePos) {\n  return Boolean(Util.POINT_RADIUS >= Util.distance(this.pos, mousePos));\n};\n\nPoint.prototype.draw = function (ctx) {\n  ctx.fillStyle = this.isMoving ? Color.MOVING_POINT : Color.STATIC_POINT;\n\n  ctx.beginPath();\n  ctx.arc(\n    this.pos[0], this.pos[1], Util.POINT_RADIUS, 0, 2 * Math.PI, true\n  );\n  ctx.fill();\n};\n\nPoint.hasEnoughSpace = function(newPos, takenPositions) {\n  let hasEnoughSpace = true;\n  takenPositions.forEach(function(pos) {\n    let xTooClose = Boolean(Math.abs(newPos[0] - pos[0]) < 100);\n    let yTooClose = Boolean(Math.abs(newPos[1] - pos[1]) < 100);\n    if (xTooClose && yTooClose) {\n      hasEnoughSpace = false;\n    }\n  });\n\n  return hasEnoughSpace;\n};\n\nmodule.exports = Point;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/point.js\n// module id = 3\n// module chunks = 0","const Game = require(\"./game\");\n\nconst GameView = function (game, ctx) {\n  this.ctx = ctx;\n  this.game = game;\n  this.game.draw(ctx);\n  this.bindEventHandlers();\n};\n\nGameView.prototype.bindEventHandlers = function () {\n  this.game.graph.bindEventHandlers({\n    redrawGameView: this.redrawGameView.bind(this)\n  });\n};\n\nGameView.prototype.redrawGameView = function (e) {\n  this.game.draw(this.ctx);\n};\n\nmodule.exports = GameView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/game_view.js\n// module id = 4\n// module chunks = 0","const Line = require(\"./line\");\nconst Point = require(\"./point\");\nconst NullObject = require(\"./null_object\");\nconst Util = require(\"./util\");\n\nconst Graph = function(){\n  this.clearGraph();\n};\n\nGraph.prototype.populate = function(opts = {}) {\n  this.renderLevelUpBtn = opts.renderLevelUpBtn ? opts.renderLevelUpBtn : this.renderLevelUpBtn;\n\n  let numPoints = opts.level;\n  let numConnectingLines = Math.floor(opts.level / 2);\n\n  if (opts.level < 2) {\n    numPoints += 4;\n  } else if (opts.level < 3) {\n    numPoints += 4;\n    numConnectingLines = 1;\n  } else if (opts.level < 6){\n    numPoints += 3;\n    numConnectingLines = 2;\n  } else if (opts.level < 8){\n    numPoints += 2;\n    numConnectingLines = 3;\n  } else if (opts.level < 10) {\n    numPoints += 1;\n    numConnectingLines = 4;\n  } else if (opts.level > 14 ){\n    numPoints -= Math.floor(opts.level / 4);\n    if (opts.level > 16) numConnectingLines = 7;\n  }\n\n  this.clearGraph();\n  this.makePoints(numPoints);\n  this.makeBaseLines(numPoints);\n  this.makeConnectingLines(numConnectingLines);\n  Line.setIntersectionPositions(this.lines);\n  this.countIntersections();\n  if (this.intersectionCount < 3) {\n    this.populate(opts);\n  } else if (this.redrawGameView) {\n    document.getElementById('move-count').innerHTML = `Moves: ${this.currentMoveCount}`;\n    this.redrawGameView();\n  }\n};\n\nGraph.prototype.countIntersections = function () {\n  let allLines = this.movingLines.length > 1 ? [].concat(this.lines, this.movingLines) : this.lines;\n  this.intersectionCount = Line.intersectionCount(allLines);\n};\n\nGraph.prototype.clearGraph = function() {\n  this.lines = [];\n  this.points = [];\n  this.pointPositions = [];\n  this.currentMoveCount = 0;\n  this.intersectionCount = 0;\n  this.timer = null;\n  this.elapsedTime = 0;\n  this.movingPoint = new NullObject();\n  this.movingLines = [new NullObject()];\n};\n\nGraph.prototype.makePoints = function (n) {\n  this.points = [];\n  while (this.points.length < n) {\n    const x = Math.floor(Math.random() * (Util.DIM_X - 260) + 130);\n    const y = Math.floor(Math.random() * (Util.DIM_Y - 260) + 130);\n    if (Point.hasEnoughSpace([x,y], this.pointPositions)) {\n      this.pointPositions.push([x, y]);\n      const newPoint = new Point({pos: [x, y]});\n      this.points.push(newPoint);\n    }\n  }\n};\n\nGraph.prototype.makeBaseLines = function(n){\n  this.lines = [];\n\n  for (var i = 0; i < n; i++) {\n    const startPoint = this.points[i];\n    const endPoint = this.points[i + 1] ? this.points[i + 1] : this.points[0];\n    const newLine = new Line({\n      startPoint,\n      endPoint,\n    });\n    this.lines.push(newLine);\n  }\n};\n\nGraph.prototype.makeConnectingLines = function(n){\n  let startPoint;\n  let endPoint;\n\n  let createFirstConnectingLine = () => {\n    startPoint = this.points[0];\n    endPoint = this.points[3];\n    let newLine = new Line({startPoint, endPoint});\n    this.lines.push(newLine);\n  };\n\n  let createSecondConnectingLine = () => {\n    startPoint = this.points[0];\n    endPoint = this.points[4];\n    let newLine = new Line({startPoint, endPoint});\n    this.lines.push(newLine);\n  };\n\n  let createThirdConnectingLine = () => {\n    startPoint = this.points[this.points.length - 1];\n    endPoint = this.points[5];\n    let newLine = new Line({startPoint, endPoint});\n    this.lines.push(newLine);\n  };\n\n  let createNMoreConnectingLines = (nMore) => {\n    for (var i = 0; i < nMore ; i++) {\n      startPoint = this.points[this.points.length - 1];\n      endPoint = this.points[this.points.length - (i + 5)];\n      let newLine = new Line({startPoint, endPoint});\n      this.lines.push(newLine);\n      nMore -= 1;\n    }\n  };\n\n  if (n > 0) createFirstConnectingLine();\n  if (n > 1) createSecondConnectingLine();\n  if (n > 2) createThirdConnectingLine();\n  if (n > 3) createNMoreConnectingLines(n - 3);\n\n};\n\nGraph.prototype.draw = function (ctx) {\n  this.allObjects().forEach((object) => {\n    object.draw(ctx);\n  });\n};\n\nGraph.prototype.allObjects = function () {\n  return [].concat(this.lines, this.points, this.movingLines, this.movingPoint);\n};\n\nGraph.prototype.startTimer = function (opts) {\n  this.timer = setInterval(()=>{\n    this.elapsedTime += 1;\n    document.getElementById('elapsed-time').innerHTML = `Time: ${this.elapsedTime}`;\n  }, 1000);\n};\n\nGraph.prototype.pauseTimer = function (opts) {\n  clearInterval(this.timer);\n  this.timer = null;\n  console.log(this.elapsedTime);\n};\n\nGraph.prototype.resetTimer = function (opts) {\n  this.elapsedTime = 0;\n  document.getElementById('elapsed-time').innerHTML = `Time: ${this.elapsedTime}`;\n};\n\nGraph.prototype.bindEventHandlers = function (opts) {\n  this.redrawGameView = opts.redrawGameView;\n  document.onmousedown = this.onMouseDown.bind(this);\n};\n\nGraph.prototype.onMouseDown = function(e) {\n  let mousePos = [e.offsetX, e.offsetY];\n  if (this.isMouseOnPoint(mousePos)) {\n    this.currentMoveCount += 1;\n    document.getElementById('move-count').innerHTML = `Moves: ${this.currentMoveCount}`;\n    this.isolateMovingObjects(mousePos);\n    document.onmousemove = this.onMouseMove.bind(this);\n    document.onmouseup = this.onMouseUp.bind(this);\n  }\n};\n\nGraph.prototype.onMouseMove = function(e){\n  let mouseX = e.offsetX;\n  let mouseY = e.offsetY;\n  let mousePos = [mouseX, mouseY];\n  this.updateMovingObjects(mousePos);\n  this.redrawGameView();\n};\n\nGraph.prototype.onMouseUp = function(e){\n  let mouseX = e.offsetX;\n  let mouseY = e.offsetY;\n  let mousePos = [mouseX, mouseY];\n  this.settlizeMovingObjects(mousePos);\n  this.redrawGameView();\n  if (this.isPlanar()) {\n    this.renderLevelUpBtn();\n  }\n  document.onmousemove = null;\n  document.onmouseup = null;\n};\n\nGraph.prototype.setMovingPoint = function (mousePos) {\n  this.movingPoint = this.points.filter(point => point.isMouseOnMe(mousePos))[0];\n};\n\nGraph.prototype.setMovingLines = function () {\n  this.movingLines = this.lines.filter(line => {\n    let isStartPointMoving = Util.samePos(line.startPoint.pos, this.movingPoint.pos);\n    let isEndPointMoving = Util.samePos(line.endPoint.pos, this.movingPoint.pos);\n    if (isStartPointMoving) {\n      line.startPoint.isMoving = true;\n    } else if (isStartPointMoving){\n      line.endPoint.isMoving = true;\n    }\n    return (isStartPointMoving || isEndPointMoving);\n  });\n};\n\nGraph.prototype.removeMovingLinesfromLinesArr = function () {\n  this.lines = this.lines.filter(line => {\n    return !(line.startPoint.isMoving || line.endPoint.isMoving);\n  });\n};\n\nGraph.prototype.removeMovingPointfromPointsArr = function (mousePos) {\n  this.points = this.points.filter(point => !point.isMouseOnMe(mousePos));\n};\n\nGraph.prototype.isolateMovingObjects = function (mousePos) {\n  this.setMovingPoint(mousePos);\n  this.setMovingLines();\n  this.removeMovingPointfromPointsArr(mousePos);\n  this.removeMovingLinesfromLinesArr();\n  this.movingPoint.isMoving = true;\n};\n\nGraph.prototype.settlizeMovingObjects = function (mousePos) {\n  this.updateMovingObjects(mousePos);\n  this.movingPoint.isMoving = false;\n  this.movingLines.forEach(line => {\n    if (line.startPoint.isMoving){\n      line.startPoint.isMoving = false;\n    } else if (line.endPoint.isMoving){\n      line.endPoint.isMoving = false;\n    }\n  });\n  this.points = this.points.concat(this.movingPoint);\n  this.lines = this.lines.concat(this.movingLines);\n  this.movingPoint = new NullObject();\n  this.movingLines = [new NullObject()];\n};\n\nGraph.prototype.updateMovingObjects = function (mousePos) {\n  this.moveMovingObjects(mousePos);\n  Line.setIntersectionPositions([].concat(this.lines, this.movingLines));\n};\n\nGraph.prototype.isPlanar = function () {\n  this.countIntersections();\n  return Boolean(this.intersectionCount < 1);\n};\n\nGraph.prototype.moveMovingObjects = function (mousePos) {\n  mousePos = [\n    mousePos[0] - Util.POINT_RADIUS,\n    mousePos[1] - Util.POINT_RADIUS\n  ];\n\n  this.movingPoint.pos = mousePos;\n  this.movingLines.forEach(line => {\n    if (line.startPoint.isMoving){\n      line.startPoint.pos = mousePos;\n    } else if (line.endPoint.isMoving){\n      line.endPoint.pos = mousePos;\n    }\n    line.setSlopeAndYIntercept();\n  });\n};\n\nGraph.prototype.isMouseOnPoint = function (mousePos) {\n  return Boolean(this.points.filter(point => point.isMouseOnMe(mousePos))[0]);\n};\n\nmodule.exports = Graph;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/graph.js\n// module id = 5\n// module chunks = 0","const Util = require(\"./util\");\nconst Color = require(\"./color\");\nconst Point = require(\"./point\");\n\n\nconst Line = function (options) {\n  this.startPoint = options.startPoint;\n  this.endPoint = options.endPoint;\n  this.setSlopeAndYIntercept();\n\n  this.intersectionPositions = [];\n};\n\nLine.prototype.setSlopeAndYIntercept = function () {\n  this.slope = (this.startPoint.pos[1] - this.endPoint.pos[1]) / (this.startPoint.pos[0] - this.endPoint.pos[0]);\n  this.yIntercept = this.startPoint.pos[1] - (this.slope * this.startPoint.pos[0]);\n};\n\nLine.prototype.draw = function (ctx) {\n  ctx.strokeStyle = (this.intersectionPositions.length > 0) ? Color.INTERSECTED_LINE : Color.LINE;\n  ctx.lineWidth = Util.LINE_WIDTH;\n  ctx.beginPath();\n  ctx.moveTo(this.startPoint.pos[0], this.startPoint.pos[1]);\n  ctx.lineTo(this.endPoint.pos[0], this.endPoint.pos[1]);\n  ctx.stroke();\n};\n\nLine.prototype.equals = function(otherLine) {\n  return Boolean((this.startPoint.pos[0] === otherLine.startX) &&\n    (this.startPoint.pos[1] === otherLine.startY) &&\n    (this.endPoint.pos[0] === otherLine.endX) &&\n    (this.endPoint.pos[1] === otherLine.endY));\n};\n\nLine.prototype.intersectionPos = function (otherLine) {\n  //return null if lines are parallel\n  if (this.equals(otherLine)) return null;\n  if (this.isAdjacentTo(otherLine)) return null;\n\n  let commonX = ((otherLine.yIntercept - this.yIntercept) / (this.slope - otherLine.slope));\n  let commonY = (this.slope * commonX) + this.yIntercept;\n  let isValidIntersection = Boolean(\n    this.posInRange([commonX, commonY])\n    && otherLine.posInRange([commonX, commonY])\n  );\n\n  if (isValidIntersection) {\n    return [commonX, commonY];\n  }\n\n  return null;\n};\n\nLine.prototype.intersectsWith = function (otherLine) {\n  return Boolean(this.intersectionPos(otherLine));\n};\n\nLine.prototype.isAdjacentTo = function (otherLine) {\n  return Boolean(\n    Util.samePos(this.startPoint.pos, otherLine.startPoint.pos) ||\n    Util.samePos(this.startPoint.pos, otherLine.endPoint.pos) ||\n    Util.samePos(this.endPoint.pos, otherLine.endPoint.pos) ||\n    Util.samePos(this.endPoint.pos, otherLine.startPoint.pos)\n  );\n};\n\nLine.setIntersectionPositions = function(allLines) {\n  allLines.forEach(line => {\n    line.setIntersectionPositions(allLines);\n    // console.log(line.intersectionPositions);\n  });\n};\n\nLine.intersectionCount = function(allLines) {\n  let allPos = [];\n  allLines.forEach(line => {\n    line.setIntersectionPositions(allLines);\n    allPos = allPos.concat(line.intersectionPositions);\n  });\n  return Util.uniqPositions(allPos).length;\n};\n\nLine.prototype.setIntersectionPositions = function(allLines) {\n  let intersectionPositions = [];\n\n  allLines.forEach((line, i) => {\n    if (this.intersectsWith(line)) {\n      intersectionPositions.push(this.intersectionPos(line));\n    }\n  });\n\n  this.intersectionPositions = Util.uniqPositions(intersectionPositions);\n};\n\nLine.prototype.posInRange = function (pos) {\n  const x = pos[0];\n  const y = pos[1];\n\n  const isXInRange = Util.inRange(this.startPoint.pos[0], this.endPoint.pos[0], x) &&\n    Util.inRange(0, Util.DIM_X, x);\n  const isYInRange = Util.inRange(this.startPoint.pos[1], this.endPoint.pos[1], y) &&\n    Util.inRange(0, Util.DIM_Y, y);\n\n  return Boolean(isXInRange && isYInRange);\n};\n\nmodule.exports = Line;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/line.js\n// module id = 6\n// module chunks = 0","const NullObject = function () {\n  this.intersectionPositions = [];\n};\n\nNullObject.prototype.draw = function (ctx) {\n};\n\nmodule.exports = NullObject;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/null_object.js\n// module id = 7\n// module chunks = 0","const Game = require(\"./game\");\nconst GameView = require(\"./game_view\");\nconst Util = require(\"./util\");\n\ndocument.addEventListener(\"DOMContentLoaded\", function(){\n  //set canvas size\n  const canvasEl = document.getElementById(\"canvas\");\n  canvasEl.width = Util.DIM_X;\n  canvasEl.height = Util.DIM_Y;\n\n  const game = new Game();\n  const ctx = canvasEl.getContext(\"2d\");\n  new GameView(game, ctx); //.start();\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/planarity_knot.js\n// module id = 8\n// module chunks = 0","const Player = function(opts) {\n  this.score = 0;\n};\n\nmodule.exports = Player;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/player.js\n// module id = 9\n// module chunks = 0"],"sourceRoot":""}