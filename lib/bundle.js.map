{"version":3,"sources":["webpack:///webpack/bootstrap b9f0530d275d5710a2a5","webpack:///./lib/util.js","webpack:///./lib/color.js","webpack:///./lib/game.js","webpack:///./lib/point.js","webpack:///./lib/game_view.js","webpack:///./lib/graph.js","webpack:///./lib/line.js","webpack:///./lib/planarity_puzzle.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AChEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACNA;AACA;AACA;;AAEA,gBAAgB;AAChB;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB,mBAAmB;;AAEnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;;;;;;AC5BA;AACA;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;;;;;;AChFA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACRA;AACA;AACA;;AAEA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,IAAI;AAClC;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,YAAY;AAC9C;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;;;;;;ACvFA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;ACpFA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,SAAS;AAClC;AACA,0BAA0B;AAC1B,CAAC","file":"./lib/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b9f0530d275d5710a2a5","const Util = {\n  inherits(ChildClass, ParentClass) {\n    ChildClass.prototype = Object.create(ParentClass.prototype);\n    ChildClass.prototype.constructor = ChildClass;\n  },\n\n  distance(pos1, pos2) {\n    const x1 = pos1[0];\n    const y1 = pos1[1];\n\n    const x2 = pos2[0];\n    const y2 = pos2[1];\n\n    return Math.sqrt(\n      Math.pow((x2 - x1), 2) + Math.pow((y2 - y1), 2)\n    );\n  },\n\n  inRange(num1, num2, numTest){\n\n    let min = (num1 <= num2) ? num1 : num2;\n    let max = (num1 <= num2) ? num2 : num1;\n\n    return Boolean(numTest > min && numTest < max);\n  },\n\n  posInRange(startPos, endPos, testPos){\n    const testX = testPos[0];\n    const testY = testPos[1];\n\n    const startX = startPos[0];\n    const startY = startPos[1];\n\n    const endX = endPos[0];\n    const endY = endPos[1];\n\n    const isXInRange = Util.inRange(startX, endX, testX);\n    const isYInRange = Util.inRange(startY, endY, testY);\n\n    return Boolean(isXInRange && isYInRange);\n  },\n\n  uniqPositions(posArray){\n    let uniqPositions = [];\n    posArray.forEach((pos1) => {\n      let isUniq = true;\n      uniqPositions.forEach((pos2) => {\n        let x1 = Math.floor(pos1[0]);\n        let y1 = Math.floor(pos1[1]);\n        let x2 = Math.floor(pos2[0]);\n        let y2 = Math.floor(pos2[1]);\n\n        if (x1 === x2 && y1 === y2) isUniq = false;\n      });\n\n      if(isUniq) uniqPositions.push(pos1);\n    });\n    return uniqPositions;\n  },\n\n  DIM_X: window.innerWidth - 100,\n  DIM_Y: window.innerHeight - 100,\n  POINT_RADIUS: 10,\n  LINE_WIDTH: 5\n};\n\nmodule.exports = Util;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/util.js\n// module id = 0\n// module chunks = 0","module.exports = {\n\tSTATIC_POINT: \"#4448AF\",\n\tMOVING_POINT: \"#7073CC\",\n  BG: \"#101010\",\n  LINE: \"#B1E0C0\",\n  INTERSECTED_LINE: \"#43B768\"\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/color.js\n// module id = 1\n// module chunks = 0","const Graph = require(\"./graph\");\nconst Color = require(\"./color\");\nconst Util = require(\"./util\");\n\nvar _startX = 0;            // mouse starting positions\nvar _startY = 0;\nvar _offsetX = 0;           // current element offset\nvar _offsetY = 0;\nvar _dragElement;           // needs to be passed from OnMouseDown to OnMouseMove\nvar _oldZIndex = 0;         // we temporarily increase the z-index during drag\n\nconst Game = function(opts) {\n  this.graph = new Graph();\n  let n = opts.level + 5;\n  this.graph.populate(n);\n\n  console.log(this.graph);\n};\n\nGame.prototype.draw = function (ctx) {\n  ctx.clearRect(0, 0, Util.DIM_X, Util.DIM_Y);\n  ctx.fillStyle = Color.BG;\n  ctx.fillRect(0, 0, Util.DIM_X, Util.DIM_Y);\n\n  this.graph.draw(ctx);\n};\n\n\nmodule.exports = Game;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/game.js\n// module id = 2\n// module chunks = 0","const Color = require(\"./color\");\nconst Util = require(\"./util\");\n\nconst Point = function (opts = {}) {\n  this.pos = opts.pos;\n  this.isMoving = false;\n  this.bindEventHandlers();\n};\n\nPoint.prototype.bindEventHandlers = function () {\n  document.onmousedown = this.onMouseDown.bind(this);\n  document.onmouseup = this.onMouseUp.bind(this);\n};\n\nPoint.prototype.onMouseDown = function(e) {\n  let mousePos = [e.offsetX, e.offsetY];\n  if (this.isMouseOn(mousePos)) {\n    this.isMoving = true;\n    console.log(this);\n    // document.onmousemove = this.onMouseMove;\n    console.log('mousedown, e:', e);\n    console.log('mousedown pos: [',e.offsetX, e.offsetY, ']');\n  }\n};\n\nPoint.prototype.onMouseUp = function(e){\n\n  let mouseX = e.target.offsetLeft;\n  let mouseY = e.target.offsetTop;\n  let mousePos = [mouseX, mouseY];\n  console.log('mouseup, e:', e);\n  console.log('mouseup pos:', mousePos);\n  // document.onmousemove = null;\n  console.log(mousePos);\n  if (this.isMouseOn(mousePos)) {\n    this.isMoving = false;\n  }\n};\n\nPoint.prototype.onMouseMove = function(e){\n  // console.log('mousemove, e:', e);\n  //\n  // let mouseX = parseInt(\n  //   e.target.style.left.slice(0, e.target.style.left.length - 2)\n  // );\n  // let mouseY = parseInt(\n  //   e.target.style.top.slice(0, e.target.style.top.length - 2)\n  // );\n  // let mousePos = [mouseX, mouseY];\n  //\n  // console.log(mousePos);\n};\n\nPoint.prototype.isMouseOn = function(mousePos) {\n  return Boolean(Util.POINT_RADIUS <= Util.distance(this.pos, mousePos));\n};\n\nPoint.prototype.draw = function (ctx) {\n  ctx.fillStyle = this.isMoving ? Color.MOVING_POINT : Color.STATIC_POINT;\n\n  ctx.beginPath();\n  ctx.arc(\n    this.pos[0], this.pos[1], Util.POINT_RADIUS, 0, 2 * Math.PI, true\n  );\n  ctx.fill();\n};\n\nPoint.hasEnoughSpace = function(newPos, takenPositions) {\n  let hasEnoughSpace = true;\n  takenPositions.forEach(function(pos) {\n    let xTooClose = Boolean(Math.abs(newPos[0] - pos[0]) < 100);\n    let yTooClose = Boolean(Math.abs(newPos[1] - pos[1]) < 100);\n    if (xTooClose && yTooClose) {\n      hasEnoughSpace = false;\n    }\n  });\n\n  return hasEnoughSpace;\n};\n\nmodule.exports = Point;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/point.js\n// module id = 3\n// module chunks = 0","const Game = require(\"./game\");\n\nconst GameView = function (game, ctx) {\n  this.ctx = ctx;\n  this.game = game;\n  this.game.draw(ctx);\n};\n\nmodule.exports = GameView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/game_view.js\n// module id = 4\n// module chunks = 0","const Line = require(\"./line\");\nconst Point = require(\"./point\");\nconst Util = require(\"./util\");\n\nconst Graph = function(opts = {}){\n  this.lines = [];\n  this.points = [];\n  this.pointPositions = [];\n  this.intersectionPositions = [];\n  this.intersectionPoints = [];\n};\n\nGraph.prototype.populate = function(n) {\n  this.reset();\n  this.makePoints(n);\n  this.makeLines();\n  this.setIntersectionPositions();\n  this.setIntersectionPoints();\n};\n\nGraph.prototype.setIntersectionPositions = function() {\n  this.intersectionPositions = [];\n\n  let intPositions = [];\n  this.lines.forEach(line => {\n    line.setIntersectionPositions(this.lines);\n    line.intersectionPositions.forEach(intPos => {\n      intPositions.push(intPos);\n    });\n  });\n\n  this.intersectionPositions = Util.uniqPositions(intPositions);\n};\n\nGraph.prototype.setIntersectionPoints = function() {\n  this.intersectionPoints = [];\n  Util.uniqPositions(this.intersectionPositions).forEach(pos => {\n    let newPoint = new Point({pos});\n    this.intersectionPoints.push(newPoint);\n  });\n};\n\nGraph.prototype.reset = function() {\n  this.lines = [];\n  this.points = [];\n  this.pointPositions = [];\n  this.intersectionPositions = [];\n  this.intersectionPoints = [];\n};\n\nGraph.prototype.makePoints = function (n) {\n  this.points = [];\n  while (this.points.length < n) {\n    const x = Math.floor(Math.random() * (Util.DIM_X - 260) + 130);\n    const y = Math.floor(Math.random() * (Util.DIM_Y - 260) + 130);\n    if (Point.hasEnoughSpace([x,y], this.pointPositions)) {\n      this.pointPositions.push([x, y]);\n      const newPoint = new Point({pos: [x, y]});\n      this.points.push(newPoint);\n    }\n  }\n};\n\nGraph.prototype.makeLines = function(){\n  this.lines = [];\n\n  for (var i = 0; i < this.points.length; i++) {\n    const startPoint = this.points[i];\n    const endPoint = this.points[i + 1] ? this.points[i + 1] : this.points[0];\n    const newLine = new Line({\n      startPoint,\n      endPoint,\n    });\n    this.lines.push(newLine);\n  }\n};\n\nGraph.prototype.draw = function (ctx) {\n  this.allObjects().forEach((object) => {\n    object.draw(ctx);\n  });\n};\n\nGraph.prototype.allObjects = function () {\n  return [].concat(this.lines, this.points);\n};\n\nmodule.exports = Graph;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/graph.js\n// module id = 5\n// module chunks = 0","const Util = require(\"./util\");\nconst Color = require(\"./color\");\nconst Point = require(\"./point\");\n\n\nconst Line = function (options) {\n  this.startPoint = options.startPoint;\n  this.startX = this.startPoint.pos[0];\n  this.startY = this.startPoint.pos[1];\n\n  this.endPoint = options.endPoint;\n  this.endX = this.endPoint.pos[0];\n  this.endY = this.endPoint.pos[1];\n\n  this.slope = (this.startY - this.endY) / (this.startX - this.endX);\n  this.yIntercept = this.startY - (this.slope * this.startX);\n\n  this.intersectionPositions = [];\n};\n\nLine.prototype.draw = function (ctx) {\n  ctx.strokeStyle = (this.intersectionPositions.length > 0) ? Color.INTERSECTED_LINE : Color.LINE;\n  ctx.lineWidth = Util.LINE_WIDTH;\n  ctx.beginPath();\n  ctx.moveTo(this.startX, this.startY);\n  ctx.lineTo(this.endX, this.endY);\n  ctx.stroke();\n};\n\nLine.prototype.equals = function(otherLine) {\n  return Boolean((this.startX === otherLine.startX) &&\n    (this.startY === otherLine.startY) &&\n    (this.endX === otherLine.endX) &&\n    (this.endY === otherLine.endY));\n};\n\nLine.prototype.intersectionPos = function (otherLine) {\n  //return null if lines are parallel\n  if (otherLine.slope - this.slope === 0) return null;\n\n\n  let commonX = (otherLine.yIntercept - this.yIntercept)/(this.slope - otherLine.slope);\n  let commonY = (this.slope * commonX) + this.yIntercept;\n  let isValidIntersection = Boolean(\n    this.posInRange([commonX, commonY])\n    && otherLine.posInRange([commonX, commonY])\n  );\n\n  if (isValidIntersection) {\n    return [commonX, commonY];\n  }\n\n  return null;\n};\n\nLine.prototype.intersectsWith = function (otherLine) {\n  return Boolean(this.intersectionPos(otherLine));\n};\n\n\nLine.prototype.setIntersectionPositions = function(allLines) {\n  let intersectionPositions = [];\n\n  allLines.forEach((line, i) => {\n    if (this.intersectsWith(line)) {\n      intersectionPositions.push(this.intersectionPos(line));\n    }\n  });\n\n  this.intersectionPositions = Util.uniqPositions(intersectionPositions);\n};\n\nLine.prototype.posInRange = function (pos) {\n  const x = pos[0];\n  const y = pos[1];\n\n  const isXInRange = Util.inRange(this.startX, this.endX, x) &&\n    Util.inRange(0, Util.DIM_X, x);\n  const isYInRange = Util.inRange(this.startY, this.endY, y) &&\n    Util.inRange(0, Util.DIM_Y, y);\n\n  return Boolean(isXInRange && isYInRange);\n};\n\nmodule.exports = Line;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/line.js\n// module id = 6\n// module chunks = 0","const Game = require(\"./game\");\nconst GameView = require(\"./game_view\");\nconst Util = require(\"./util\");\n\ndocument.addEventListener(\"DOMContentLoaded\", function(){\n  //set canvas size\n  const canvasEl = document.getElementById(\"canvas\");\n  canvasEl.width = Util.DIM_X;\n  canvasEl.height = Util.DIM_Y;\n\n  const game = new Game({level: 1});\n  const ctx = canvasEl.getContext(\"2d\");\n  new GameView(game, ctx); //.start();\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/planarity_puzzle.js\n// module id = 7\n// module chunks = 0"],"sourceRoot":""}